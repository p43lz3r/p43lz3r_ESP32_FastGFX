#include <Arduino.h>
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_rgb.h"
#include "driver/gpio.h"
#include "esp_heap_caps.h"
#include "simple_touch.h"

// Display configuration
#define LCD_PIXEL_CLOCK_HZ (16 * 1000 * 1000)
#define LCD_BK_LIGHT_ON_LEVEL 1
#define LCD_BK_LIGHT_OFF_LEVEL !LCD_BK_LIGHT_ON_LEVEL

#define LCD_H_RES 800
#define LCD_V_RES 480

// RGB pins - same as your original configuration
#define PIN_NUM_DE 5
#define PIN_NUM_VSYNC 3
#define PIN_NUM_HSYNC 46
#define PIN_NUM_PCLK 7
#define PIN_NUM_DATA0 14  // B0
#define PIN_NUM_DATA1 38  // B1
#define PIN_NUM_DATA2 18  // B2
#define PIN_NUM_DATA3 17  // B3
#define PIN_NUM_DATA4 10  // B4
#define PIN_NUM_DATA5 39  // G0
#define PIN_NUM_DATA6 0   // G1
#define PIN_NUM_DATA7 45  // G2
#define PIN_NUM_DATA8 48  // G3
#define PIN_NUM_DATA9 47  // G4
#define PIN_NUM_DATA10 21 // G5
#define PIN_NUM_DATA11 1  // R0
#define PIN_NUM_DATA12 2  // R1
#define PIN_NUM_DATA13 42 // R2
#define PIN_NUM_DATA14 41 // R3
#define PIN_NUM_DATA15 40 // R4

esp_lcd_panel_handle_t panel_handle = NULL;
uint16_t *frame_buffer = NULL;

// Define some colors
// RGB565 color definitions
#define COLOR_BLACK 0x0000
#define COLOR_WHITE 0xFFFF
#define COLOR_RED 0xF800
#define COLOR_GREEN 0x07E0
#define COLOR_BLUE 0x001F
#define COLOR_YELLOW 0xFFE0
#define COLOR_MAGENTA 0xF81F
#define COLOR_CYAN 0x07FF

// Fast Graphics Library v1.0 - Essential Functions Only
// Add these to replace your existing drawing functions in main.cpp

// =============================================================================
// CORE OPTIMIZED FUNCTIONS - Fast and beginner-friendly
// =============================================================================

// Fast pixel drawing - inline for maximum speed
inline void fastPixel(int16_t x, int16_t y, uint16_t color)
{
    if (x >= 0 && x < LCD_H_RES && y >= 0 && y < LCD_V_RES)
    {
        frame_buffer[y * LCD_H_RES + x] = color;
    }
}

// =============================================================================
// FUNCTION 1: FAST FILLED RECTANGLE
// Most important function - used for backgrounds, buttons, bars, etc.
// =============================================================================

void fastFillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)
{
    // Input validation and clipping
    if (x >= LCD_H_RES || y >= LCD_V_RES || w <= 0 || h <= 0)
        return;

    // Clip to screen boundaries
    if (x < 0)
    {
        w += x;
        x = 0;
    }
    if (y < 0)
    {
        h += y;
        y = 0;
    }
    if (x + w > LCD_H_RES)
        w = LCD_H_RES - x;
    if (y + h > LCD_V_RES)
        h = LCD_V_RES - y;

    // Fast bulk filling - draw entire horizontal lines
    for (int16_t row = 0; row < h; row++)
    {
        uint16_t *ptr = &frame_buffer[(y + row) * LCD_H_RES + x];
        int16_t pixels = w;

        // Unrolled loop for speed (process 4 pixels at once when possible)
        while (pixels >= 4)
        {
            *ptr++ = color;
            *ptr++ = color;
            *ptr++ = color;
            *ptr++ = color;
            pixels -= 4;
        }

        // Handle remaining pixels
        while (pixels > 0)
        {
            *ptr++ = color;
            pixels--;
        }
    }
}

// =============================================================================
// FUNCTION 2: FAST FILLED CIRCLE
// Perfect for buttons, indicators, dots, and UI elements
// Uses integer-only Bresenham algorithm - no floating point math!
// =============================================================================

void fastFillCircle(int16_t x0, int16_t y0, int16_t radius, uint16_t color)
{
    if (radius <= 0)
        return;

    int16_t x = 0;
    int16_t y = radius;
    int16_t decision = 1 - radius;

    // Draw center line
    fastFillRect(x0 - radius, y0, 2 * radius + 1, 1, color);

    while (x < y)
    {
        if (decision < 0)
        {
            decision += 2 * x + 3;
        }
        else
        {
            decision += 2 * (x - y) + 5;

            // Draw horizontal lines for filled circle
            fastFillRect(x0 - x, y0 + y, 2 * x + 1, 1, color);
            fastFillRect(x0 - x, y0 - y, 2 * x + 1, 1, color);

            y--;
        }

        x++;

        // Draw horizontal lines for current x
        if (x <= y)
        {
            fastFillRect(x0 - y, y0 + x, 2 * y + 1, 1, color);
            fastFillRect(x0 - y, y0 - x, 2 * y + 1, 1, color);
        }
    }
}

// =============================================================================
// FUNCTION 3: FAST LINE DRAWING
// Essential for borders, graphs, wireframes, and connecting elements
// Uses optimized Bresenham algorithm
// =============================================================================

void fastLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)
{
    // Handle special cases first (much faster)
    if (y0 == y1)
    {
        // Horizontal line - use fast rect
        if (x0 > x1)
        {
            int16_t temp = x0;
            x0 = x1;
            x1 = temp;
        }
        fastFillRect(x0, y0, x1 - x0 + 1, 1, color);
        return;
    }

    if (x0 == x1)
    {
        // Vertical line - use fast rect
        if (y0 > y1)
        {
            int16_t temp = y0;
            y0 = y1;
            y1 = temp;
        }
        fastFillRect(x0, y0, 1, y1 - y0 + 1, color);
        return;
    }

    // Diagonal line - optimized Bresenham
    int16_t dx = abs(x1 - x0);
    int16_t dy = abs(y1 - y0);
    int16_t sx = (x0 < x1) ? 1 : -1;
    int16_t sy = (y0 < y1) ? 1 : -1;
    int16_t err = dx - dy;

    int16_t x = x0;
    int16_t y = y0;

    while (true)
    {
        fastPixel(x, y, color);

        if (x == x1 && y == y1)
            break;

        int16_t e2 = 2 * err;
        if (e2 > -dy)
        {
            err -= dy;
            x += sx;
        }
        if (e2 < dx)
        {
            err += dx;
            y += sy;
        }
    }
}

// =============================================================================
// CONVENIENCE FUNCTIONS - Built on top of the 3 core functions
// =============================================================================

// Clear entire screen (uses fast rect)
void fastClear(uint16_t color = COLOR_BLACK)
{
    fastFillRect(0, 0, LCD_H_RES, LCD_V_RES, color);
}

// Draw rectangle outline (uses fast lines)
void fastRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)
{
    fastLine(x, y, x + w - 1, y, color);                 // Top
    fastLine(x, y + h - 1, x + w - 1, y + h - 1, color); // Bottom
    fastLine(x, y, x, y + h - 1, color);                 // Left
    fastLine(x + w - 1, y, x + w - 1, y + h - 1, color); // Right
}

// Draw circle outline (uses optimized Bresenham)
void fastCircle(int16_t x0, int16_t y0, int16_t radius, uint16_t color)
{
    if (radius <= 0)
        return;

    int16_t x = 0;
    int16_t y = radius;
    int16_t decision = 1 - radius;

    // 8-fold symmetry for maximum efficiency
    while (x <= y)
    {
        fastPixel(x0 + x, y0 + y, color);
        fastPixel(x0 - x, y0 + y, color);
        fastPixel(x0 + x, y0 - y, color);
        fastPixel(x0 - x, y0 - y, color);
        fastPixel(x0 + y, y0 + x, color);
        fastPixel(x0 - y, y0 + x, color);
        fastPixel(x0 + y, y0 - x, color);
        fastPixel(x0 - y, y0 - x, color);

        if (decision < 0)
        {
            decision += 2 * x + 3;
        }
        else
        {
            decision += 2 * (x - y) + 5;
            y--;
        }
        x++;
    }
}

// =============================================================================
// SIMPLE DEMO FUNCTION - Test all functions
// =============================================================================

void fastGraphicsDemo()
{
    // Clear screen
    fastClear(COLOR_BLACK);

    // Test filled rectangles
    fastFillRect(50, 50, 100, 60, COLOR_RED);
    fastFillRect(200, 50, 100, 60, COLOR_GREEN);
    fastFillRect(350, 50, 100, 60, COLOR_BLUE);

    // Test rectangle outlines
    fastRect(50, 150, 100, 60, COLOR_YELLOW);
    fastRect(200, 150, 100, 60, COLOR_CYAN);
    fastRect(350, 150, 100, 60, COLOR_MAGENTA);

    // Test filled circles
    fastFillCircle(100, 280, 30, COLOR_WHITE);
    fastFillCircle(250, 280, 35, COLOR_RED);
    fastFillCircle(400, 280, 25, COLOR_GREEN);

    // Test circle outlines
    fastCircle(100, 380, 40, COLOR_BLUE);
    fastCircle(250, 380, 45, COLOR_YELLOW);
    fastCircle(400, 380, 35, COLOR_CYAN);

    // Test lines
    fastLine(500, 50, 700, 150, COLOR_WHITE);
    fastLine(500, 150, 700, 50, COLOR_MAGENTA);
    fastLine(500, 200, 700, 200, COLOR_RED);   // Horizontal
    fastLine(600, 250, 600, 350, COLOR_GREEN); // Vertical

    // Update display
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, frame_buffer);
}

// =============================================================================
// USAGE EXAMPLES - Copy these to your loop() or other functions
// =============================================================================

/*
// Basic shapes
fastClear(COLOR_BLACK);                           // Clear screen
fastFillRect(100, 100, 200, 150, COLOR_BLUE);    // Blue rectangle
fastFillCircle(300, 200, 50, COLOR_RED);         // Red circle
fastLine(50, 50, 400, 300, COLOR_WHITE);         // White line

// UI Elements
fastFillRect(50, 400, 200, 40, COLOR_GREEN);     // Green button
fastRect(50, 400, 200, 40, COLOR_WHITE);         // White border
fastFillCircle(400, 420, 15, COLOR_RED);         // Red indicator dot

// Simple graph/chart
for (int x = 0; x < 400; x += 20) {
    int y = 240 + sin(x * 0.1) * 50;  // Sine wave
    fastFillCircle(x + 100, y, 3, COLOR_YELLOW);
}

// Always update display after drawing
esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, frame_buffer);
*/

void setup()
{
    Serial.begin(115200);

    // Initialize touch
    touch_init();

    // Allocate frame buffer
    frame_buffer = (uint16_t *)malloc(LCD_H_RES * LCD_V_RES * sizeof(uint16_t));
    if (!frame_buffer)
    {
        Serial.println("Failed to allocate frame buffer!");
        return;
    }

    // Configure RGB LCD panel
    esp_lcd_rgb_panel_config_t panel_config = {
        .clk_src = LCD_CLK_SRC_DEFAULT,
        .timings = {
            .pclk_hz = LCD_PIXEL_CLOCK_HZ,
            .h_res = LCD_H_RES,
            .v_res = LCD_V_RES,
            .hsync_pulse_width = 4,
            .hsync_back_porch = 8,
            .hsync_front_porch = 8,
            .vsync_pulse_width = 4,
            .vsync_back_porch = 8,
            .vsync_front_porch = 8,
            .flags = {
                .hsync_idle_low = 0,
                .vsync_idle_low = 0,
                .de_idle_high = 0,
                .pclk_active_neg = 1,
                .pclk_idle_high = 0,
            },
        },
        .data_width = 16,
        .bits_per_pixel = 16,
        .num_fbs = 1,
        .bounce_buffer_size_px = 0,
        .sram_trans_align = 4,
        .psram_trans_align = 64,
        .hsync_gpio_num = PIN_NUM_HSYNC,
        .vsync_gpio_num = PIN_NUM_VSYNC,
        .de_gpio_num = PIN_NUM_DE,
        .pclk_gpio_num = PIN_NUM_PCLK,
        .disp_gpio_num = GPIO_NUM_NC,
        .data_gpio_nums = {
            PIN_NUM_DATA0,
            PIN_NUM_DATA1,
            PIN_NUM_DATA2,
            PIN_NUM_DATA3,
            PIN_NUM_DATA4,
            PIN_NUM_DATA5,
            PIN_NUM_DATA6,
            PIN_NUM_DATA7,
            PIN_NUM_DATA8,
            PIN_NUM_DATA9,
            PIN_NUM_DATA10,
            PIN_NUM_DATA11,
            PIN_NUM_DATA12,
            PIN_NUM_DATA13,
            PIN_NUM_DATA14,
            PIN_NUM_DATA15,
        },
        .flags = {
            .fb_in_psram = 1,
        },
    };

    // Install RGB LCD panel driver
    ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));

    // Clear screen
    fastClear(COLOR_BLACK);

    fastFillRect(100, 100, 200, 150, COLOR_BLUE); // Rectangle
    fastFillCircle(500, 200, 50, COLOR_RED);      // Circle
    fastLine(50, 50, 400, 300, COLOR_WHITE);      // Line

    // Update display
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, frame_buffer);

    Serial.println("ESP-IDF RGB Display initialized with text support!");

    // Update display
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, frame_buffer);

    Serial.println("ESP-IDF RGB Display initialized!");
}

void loop()
{
    if (touch_touched())
    {

        Serial.print("Touch at: ");
        Serial.print(touch_last_x);
        Serial.print(", ");
        Serial.println(touch_last_y);
    }

    delay(50);
}
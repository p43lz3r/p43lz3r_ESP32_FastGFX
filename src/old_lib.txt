// Simple drawing functions
void drawPixel(int16_t x, int16_t y, uint16_t color) {
    if (x >= 0 && x < LCD_H_RES && y >= 0 && y < LCD_V_RES) {
        frame_buffer[y * LCD_H_RES + x] = color;
    }
}

void fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
    for (int16_t i = x; i < x + w; i++) {
        for (int16_t j = y; j < y + h; j++) {
            drawPixel(i, j, color);
        }
    }
}

void fillScreen(uint16_t color) {
    fillRect(0, 0, LCD_H_RES, LCD_V_RES, color);
}

void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep) {
        std::swap(x0, y0);
        std::swap(x1, y1);
    }

    if (x0 > x1) {
        std::swap(x0, x1);
        std::swap(y0, y1);
    }

    int16_t dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int16_t err = dx / 2;
    int16_t ystep;

    if (y0 < y1) {
        ystep = 1;
    } else {
        ystep = -1;
    }

    for (; x0 <= x1; x0++) {
        if (steep) {
            drawPixel(y0, x0, color);
        } else {
            drawPixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
            err += dx;
        }
    }
}

void drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    drawPixel(x0, y0 + r, color);
    drawPixel(x0, y0 - r, color);
    drawPixel(x0 + r, y0, color);
    drawPixel(x0 - r, y0, color);

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        drawPixel(x0 + x, y0 + y, color);
        drawPixel(x0 - x, y0 + y, color);
        drawPixel(x0 + x, y0 - y, color);
        drawPixel(x0 - x, y0 - y, color);
        drawPixel(x0 + y, y0 + x, color);
        drawPixel(x0 - y, y0 + x, color);
        drawPixel(x0 + y, y0 - x, color);
        drawPixel(x0 - y, y0 - x, color);
    }
}

void fillCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
    drawLine(x0, y0 - r, x0, y0 - r + 2 * r + 1, color);
    int16_t f = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        drawLine(x0 + x, y0 - y, x0 + x, y0 - y + 2 * y + 1, color);
        drawLine(x0 - x, y0 - y, x0 - x, y0 - y + 2 * y + 1, color);
        drawLine(x0 + y, y0 - x, x0 + y, y0 - x + 2 * x + 1, color);
        drawLine(x0 - y, y0 - x, x0 - y, y0 - x + 2 * x + 1, color);
    }
}

// RGB565 color definitions
#define COLOR_BLACK   0x0000
#define COLOR_WHITE   0xFFFF
#define COLOR_RED     0xF800
#define COLOR_GREEN   0x07E0
#define COLOR_BLUE    0x001F
#define COLOR_YELLOW  0xFFE0
#define COLOR_MAGENTA 0xF81F
#define COLOR_CYAN    0x07FF

// Simple 8x8 font bitmap (basic ASCII characters)
const uint8_t font8x8_basic[128][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x00},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x06, 0x00},   // U+003B (;)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};

// Text drawing functions
void drawChar(int16_t x, int16_t y, char c, uint16_t color, uint16_t bg, uint8_t size) {
    if (c < 0 || c > 127) return;  // Only ASCII characters
    
    for (int8_t i = 0; i < 8; i++) {
        uint8_t line = font8x8_basic[c][i];
        for (int8_t j = 0; j < 8; j++) {
            if (line & (1 << j)) {
                if (size == 1) {
                    drawPixel(x + j, y + i, color);
                } else {
                    fillRect(x + j * size, y + i * size, size, size, color);
                }
            } else if (bg != color) {
                if (size == 1) {
                    drawPixel(x + j, y + i, bg);
                } else {
                    fillRect(x + j * size, y + i * size, size, size, bg);
                }
            }
        }
    }
}

void drawText(int16_t x, int16_t y, const char* text, uint16_t color, uint16_t bg, uint8_t size) {
    int16_t cursor_x = x;
    int16_t cursor_y = y;
    
    while (*text) {
        if (*text == '\n') {
            cursor_y += size * 8;
            cursor_x = x;
        } else if (*text == '\r') {
            // ignore carriage return
        } else {
            drawChar(cursor_x, cursor_y, *text, color, bg, size);
            cursor_x += size * 8;
        }
        text++;
    }
}

// Add these enhanced graphics functions to your main.cpp file
// Place them after your existing drawing functions

// Fast line drawing functions
void drawFastVerticalLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    if (x < 0 || x >= LCD_H_RES) return;
    
    int16_t y_end = y + h;
    if (y < 0) y = 0;
    if (y_end > LCD_V_RES) y_end = LCD_V_RES;
    
    for (int16_t i = y; i < y_end; i++) {
        frame_buffer[i * LCD_H_RES + x] = color;
    }
}

void drawFastHorizontalLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
    if (y < 0 || y >= LCD_V_RES) return;
    
    int16_t x_end = x + w;
    if (x < 0) x = 0;
    if (x_end > LCD_H_RES) x_end = LCD_H_RES;
    
    for (int16_t i = x; i < x_end; i++) {
        frame_buffer[y * LCD_H_RES + i] = color;
    }
}

// Helper function for rounded rectangles
void drawRoundRectHelper(int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint8_t cornername, uint16_t color) {
    int16_t f = 1 - radius;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * radius;
    int16_t x = 0;
    int16_t y = radius;

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;
        
        if (cornername & 0x4) {
            drawPixel(x0 + x, y0 + y, color);
            drawPixel(x0 + y, y0 + x, color);
        }
        if (cornername & 0x2) {
            drawPixel(x0 + x, y0 - y, color);
            drawPixel(x0 + y, y0 - x, color);
        }
        if (cornername & 0x8) {
            drawPixel(x0 - y, y0 + x, color);
            drawPixel(x0 - x, y0 + y, color);
        }
        if (cornername & 0x1) {
            drawPixel(x0 - y, y0 - x, color);
            drawPixel(x0 - x, y0 - y, color);
        }
    }
}

void fillRoundRectHelper(int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint8_t cornername, int16_t delta, uint16_t color) {
    int16_t f = 1 - radius;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * radius;
    int16_t x = 0;
    int16_t y = radius;

    while (x < y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
        }
        x++;
        ddF_x += 2;
        f += ddF_x;

        if (cornername & 0x1) {
            drawFastVerticalLine(x0 + x, y0 - y, 2 * y + 1 + delta, color);
            drawFastVerticalLine(x0 + y, y0 - x, 2 * x + 1 + delta, color);
        }
        if (cornername & 0x2) {
            drawFastVerticalLine(x0 - x, y0 - y, 2 * y + 1 + delta, color);
            drawFastVerticalLine(x0 - y, y0 - x, 2 * x + 1 + delta, color);
        }
    }
}

// Rounded rectangle functions
void drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    int16_t max_radius = ((w < h) ? w : h) / 2;
    if (r > max_radius) r = max_radius;
    
    // Draw straight sides
    drawFastHorizontalLine(x + r, y, w - 2 * r, color);
    drawFastHorizontalLine(x + r, y + h - 1, w - 2 * r, color);
    drawFastVerticalLine(x, y + r, h - 2 * r, color);
    drawFastVerticalLine(x + w - 1, y + r, h - 2 * r, color);
    
    // Draw rounded corners
    drawRoundRectHelper(x + r, y + r, w, h, r, 1, color);
    drawRoundRectHelper(x + w - r - 1, y + r, w, h, r, 2, color);
    drawRoundRectHelper(x + w - r - 1, y + h - r - 1, w, h, r, 4, color);
    drawRoundRectHelper(x + r, y + h - r - 1, w, h, r, 8, color);
}

void fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) {
    int16_t max_radius = ((w < h) ? w : h) / 2;
    if (r > max_radius) r = max_radius;
    
    // Fill center rectangle
    fillRect(x + r, y, w - 2 * r, h, color);
    
    // Fill rounded corners
    fillRoundRectHelper(x + w - r - 1, y + r, w, h, r, 1, h - 2 * r - 1, color);
    fillRoundRectHelper(x + r, y + r, w, h, r, 2, h - 2 * r - 1, color);
}

// Ellipse functions
void drawEllipse(int16_t x0, int16_t y0, int16_t rx, int16_t ry, uint16_t color) {
    if (rx == 0 || ry == 0) return;
    
    int32_t x, y;
    int32_t rx_sq = rx * rx;
    int32_t ry_sq = ry * ry;
    int32_t two_rx_sq = 2 * rx_sq;
    int32_t two_ry_sq = 2 * ry_sq;
    int32_t p;
    int32_t px = 0;
    int32_t py = two_rx_sq * ry;

    // Region 1
    p = ry_sq - (rx_sq * ry) + (0.25 * rx_sq);
    x = 0;
    y = ry;

    while (px < py) {
        x++;
        px += two_ry_sq;
        if (p < 0) {
            p += ry_sq + px;
        } else {
            y--;
            py -= two_rx_sq;
            p += ry_sq + px - py;
        }
        
        drawPixel(x0 + x, y0 + y, color);
        drawPixel(x0 - x, y0 + y, color);
        drawPixel(x0 + x, y0 - y, color);
        drawPixel(x0 - x, y0 - y, color);
    }

    // Region 2
    p = ry_sq * (x + 0.5) * (x + 0.5) + rx_sq * (y - 1) * (y - 1) - rx_sq * ry_sq;

    while (y > 0) {
        y--;
        py -= two_rx_sq;
        if (p > 0) {
            p += rx_sq - py;
        } else {
            x++;
            px += two_ry_sq;
            p += rx_sq - py + px;
        }
        
        drawPixel(x0 + x, y0 + y, color);
        drawPixel(x0 - x, y0 + y, color);
        drawPixel(x0 + x, y0 - y, color);
        drawPixel(x0 - x, y0 - y, color);
    }
}

void fillEllipse(int16_t x0, int16_t y0, int16_t rx, int16_t ry, uint16_t color) {
    if (rx == 0 || ry == 0) return;
    
    int32_t x, y;
    int32_t rx_sq = rx * rx;
    int32_t ry_sq = ry * ry;
    int32_t two_rx_sq = 2 * rx_sq;
    int32_t two_ry_sq = 2 * ry_sq;
    int32_t p;
    int32_t px = 0;
    int32_t py = two_rx_sq * ry;

    // Draw center line
    drawFastHorizontalLine(x0 - rx, y0, 2 * rx + 1, color);

    // Region 1
    p = ry_sq - (rx_sq * ry) + (0.25 * rx_sq);
    x = 0;
    y = ry;

    while (px < py) {
        x++;
        px += two_ry_sq;
        if (p < 0) {
            p += ry_sq + px;
        } else {
            y--;
            py -= two_rx_sq;
            p += ry_sq + px - py;
        }
        
        drawFastHorizontalLine(x0 - x, y0 + y, 2 * x + 1, color);
        drawFastHorizontalLine(x0 - x, y0 - y, 2 * x + 1, color);
    }

    // Region 2
    p = ry_sq * (x + 0.5) * (x + 0.5) + rx_sq * (y - 1) * (y - 1) - rx_sq * ry_sq;

    while (y > 0) {
        y--;
        py -= two_rx_sq;
        if (p > 0) {
            p += rx_sq - py;
        } else {
            x++;
            px += two_ry_sq;
            p += rx_sq - py + px;
        }
        
        drawFastHorizontalLine(x0 - x, y0 + y, 2 * x + 1, color);
        drawFastHorizontalLine(x0 - x, y0 - y, 2 * x + 1, color);
    }
}

// Triangle functions
void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    drawLine(x0, y0, x1, y1, color);
    drawLine(x1, y1, x2, y2, color);
    drawLine(x2, y2, x0, y0, color);
}

void fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    int16_t a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
        std::swap(y0, y1);
        std::swap(x0, x1);
    }
    if (y1 > y2) {
        std::swap(y2, y1);
        std::swap(x2, x1);
    }
    if (y0 > y1) {
        std::swap(y0, y1);
        std::swap(x0, x1);
    }

    if (y0 == y2) { // Handle awkward all-on-same-line case
        a = b = x0;
        if (x1 < a) a = x1;
        else if (x1 > b) b = x1;
        if (x2 < a) a = x2;
        else if (x2 > b) b = x2;
        drawFastHorizontalLine(a, y0, b - a + 1, color);
        return;
    }

    int16_t dx01 = x1 - x0;
    int16_t dy01 = y1 - y0;
    int16_t dx02 = x2 - x0;
    int16_t dy02 = y2 - y0;
    int16_t dx12 = x2 - x1;
    int16_t dy12 = y2 - y1;

    // For upper part of triangle, find scanline crossings for segments
    int32_t sa = 0;
    int32_t sb = 0;

    if (y1 == y2) last = y1;   // Include y1 scanline
    else last = y1 - 1; // Skip it

    for (y = y0; y <= last; y++) {
        a = x0 + sa / dy01;
        b = x0 + sb / dy02;
        sa += dx01;
        sb += dx02;
        
        if (a > b) std::swap(a, b);
        drawFastHorizontalLine(a, y, b - a + 1, color);
    }

    // For lower part of triangle, find scanline crossings for segments
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for (; y <= y2; y++) {
        a = x1 + sa / dy12;
        b = x0 + sb / dy02;
        sa += dx12;
        sb += dx02;
        
        if (a > b) std::swap(a, b);
        drawFastHorizontalLine(a, y, b - a + 1, color);
    }
}

// Bezier curve functions
void drawBezier(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    // Quadratic Bezier curve
    int16_t prev_x = x0, prev_y = y0;
    
    for (int i = 1; i <= 100; i++) {
        float t = i / 100.0f;
        float u = 1.0f - t;
        float tt = t * t;
        float uu = u * u;
        
        int16_t x = uu * x0 + 2 * u * t * x1 + tt * x2;
        int16_t y = uu * y0 + 2 * u * t * y1 + tt * y2;
        
        drawLine(prev_x, prev_y, x, y, color);
        prev_x = x;
        prev_y = y;
    }
}

void drawBezier(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, int16_t x3, int16_t y3, uint16_t color) {
    // Cubic Bezier curve
    int16_t prev_x = x0, prev_y = y0;
    
    for (int i = 1; i <= 100; i++) {
        float t = i / 100.0f;
        float u = 1.0f - t;
        float tt = t * t;
        float uu = u * u;
        float uuu = uu * u;
        float ttt = tt * t;
        
        int16_t x = uuu * x0 + 3 * uu * t * x1 + 3 * u * tt * x2 + ttt * x3;
        int16_t y = uuu * y0 + 3 * uu * t * y1 + 3 * u * tt * y2 + ttt * y3;
        
        drawLine(prev_x, prev_y, x, y, color);
        prev_x = x;
        prev_y = y;
    }
}

// Arc functions - Fixed version without gaps
void drawArc(int16_t x, int16_t y, int16_t r0, int16_t r1, float angle0, float angle1, uint16_t color) {
    if (r1 < r0) std::swap(r0, r1);
    
    // Convert angles to radians and normalize
    float start_rad = angle0 * PI / 180.0f;
    float end_rad = angle1 * PI / 180.0f;
    
    // Handle angle wrapping
    if (end_rad < start_rad) end_rad += 2 * PI;
    
    // Use pixel-by-pixel approach to avoid gaps
    // Check every pixel in the bounding box
    int16_t x_min = x - r1 - 1;
    int16_t x_max = x + r1 + 1;
    int16_t y_min = y - r1 - 1;
    int16_t y_max = y + r1 + 1;
    
    for (int16_t px = x_min; px <= x_max; px++) {
        for (int16_t py = y_min; py <= y_max; py++) {
            // Calculate distance and angle for this pixel
            int16_t dx = px - x;
            int16_t dy = py - y;
            float distance = sqrt(dx * dx + dy * dy);
            
            // Check if pixel is within the radius range
            if (distance >= r0 && distance <= r1) {
                // Calculate angle for this pixel
                float pixel_angle = atan2(dy, dx);
                if (pixel_angle < 0) pixel_angle += 2 * PI;
                
                // Check if pixel is within the angle range
                bool in_range = false;
                if (end_rad - start_rad <= 2 * PI) {
                    // Normal case
                    in_range = (pixel_angle >= start_rad && pixel_angle <= end_rad);
                } else {
                    // Handle wrap-around case
                    in_range = (pixel_angle >= start_rad || pixel_angle <= (end_rad - 2 * PI));
                }
                
                if (in_range) {
                    drawPixel(px, py, color);
                }
            }
        }
    }
}

void fillArc(int16_t x, int16_t y, int16_t r0, int16_t r1, float angle0, float angle1, uint16_t color) {
    // fillArc is the same as drawArc for this implementation
    drawArc(x, y, r0, r1, angle0, angle1, color);
}

//void fillArc(int16_t x, int16_t y, int16_t r0, int16_t r1, float angle0, float angle1, uint16_t color) {
//    if (r1 < r0) std::swap(r0, r1);
//    
//    // Convert angles to radians
//    float start_rad = angle0 * PI / 180.0f;
//    float end_rad = angle1 * PI / 180.0f;
//    
//    if (end_rad < start_rad) end_rad += 2 * PI;
//    
//    float angle_step = 0.01f; // Adjust for smoothness
//    
//    for (float angle = start_rad; angle <= end_rad; angle += angle_step) {
//        float cos_a = cos(angle);
//        float sin_a = sin(angle);
//        
//        for (int16_t r = r0; r <= r1; r++) {
//            int16_t px = x + r * cos_a;
//            int16_t py = y + r * sin_a;
//            drawPixel(px, py, color);
//        }
//    }
//}

// Enhanced demo function to test all new graphics functions
void drawGraphicsDemo() {
    fillScreen(COLOR_BLACK);
    
    // Fast lines demo
    drawText(10, 10, "Fast Lines:", COLOR_WHITE, COLOR_BLACK, 1);
    drawFastHorizontalLine(120, 15, 100, COLOR_RED);
    drawFastVerticalLine(240, 10, 20, COLOR_GREEN);
    
    // Rounded rectangles
    drawText(10, 40, "Rounded Rects:", COLOR_WHITE, COLOR_BLACK, 1);
    drawRoundRect(150, 35, 80, 40, 10, COLOR_BLUE);
    fillRoundRect(250, 35, 80, 40, 15, COLOR_YELLOW);
    
    // Ellipses
    drawText(10, 90, "Ellipses:", COLOR_WHITE, COLOR_BLACK, 1);
    drawEllipse(180, 110, 30, 20, COLOR_CYAN);
    fillEllipse(280, 110, 25, 35, COLOR_MAGENTA);
    
    // Triangles
    drawText(10, 140, "Triangles:", COLOR_WHITE, COLOR_BLACK, 1);
    drawTriangle(150, 140, 180, 180, 120, 180, COLOR_RED);
    fillTriangle(220, 140, 250, 180, 190, 180, COLOR_GREEN);
    
    // Bezier curves
    drawText(10, 200, "Bezier Curves:", COLOR_WHITE, COLOR_BLACK, 1);
    drawBezier(150, 220, 200, 200, 250, 240, COLOR_BLUE);
    drawBezier(300, 220, 350, 200, 400, 200, 450, 240, COLOR_YELLOW);
    
    // Arcs
    drawText(10, 260, "Arcs:", COLOR_WHITE, COLOR_BLACK, 1);
    drawArc(180, 300, 20, 40, 0, 180, COLOR_CYAN);
    fillArc(280, 300, 15, 35, 45, 135, COLOR_MAGENTA);
    
    drawText(10, 350, "Graphics Demo Complete!", COLOR_WHITE, COLOR_BLACK, 2);
    
    // Update display
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, frame_buffer);
}